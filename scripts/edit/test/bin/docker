#!/usr/bin/env bash

# Mock docker wrapper for E2E testing of edit scripts.
#
# This script intercepts docker and docker compose commands:
# - Real docker is used for `docker info` and `docker run` (charon ceremonies)
# - Docker compose commands are mocked (container lifecycle, ASDB export/import)
#
# Environment variables:
#   REAL_DOCKER          - Path to real docker binary (required)
#   MOCK_STATE_DIR       - Directory for service state tracking (required for compose)
#   MOCK_OPERATOR_INDEX  - Operator index for ASDB pubkey generation (required for compose cp)

set -euo pipefail

# --- Helpers ---

strip_tty_flags() {
    local args=()
    local skip_next=false
    for arg in "$@"; do
        if [ "$skip_next" = true ]; then
            skip_next=false
            continue
        fi
        case "$arg" in
            -it|-ti) ;;          # combined flags
            -i|-t) ;;            # individual flags
            --interactive|--tty) ;;
            *) args+=("$arg") ;;
        esac
    done
    echo "${args[@]}"
}

state_file() {
    echo "${MOCK_STATE_DIR}/services.state"
}

mark_service() {
    local svc="$1" status="$2"
    local sf
    sf="$(state_file)"
    mkdir -p "$(dirname "$sf")"
    touch "$sf"
    if grep -q "^${svc}=" "$sf" 2>/dev/null; then
        # Use a temp file for portable in-place edit
        local tmp="${sf}.tmp"
        while IFS= read -r line; do
            if [[ "$line" == "${svc}="* ]]; then
                echo "${svc}=${status}"
            else
                echo "$line"
            fi
        done < "$sf" > "$tmp"
        mv "$tmp" "$sf"
    else
        echo "${svc}=${status}" >> "$sf"
    fi
}

is_service_up() {
    local svc="$1"
    local sf
    sf="$(state_file)"
    [ -f "$sf" ] && grep -q "^${svc}=running" "$sf" 2>/dev/null
}

generate_eip3076() {
    local dest="$1"
    local operator_index="${MOCK_OPERATOR_INDEX:-0}"

    # Find cluster-lock.json in cwd
    local lock_file="./charon/cluster-lock.json"
    if [ ! -f "$lock_file" ]; then
        lock_file="./.charon/cluster-lock.json"
    fi

    if [ ! -f "$lock_file" ]; then
        # Fallback: generate minimal valid EIP-3076
        cat > "$dest" <<'FALLBACK'
{"metadata":{"interchange_format_version":"5","genesis_validators_root":"0x0000000000000000000000000000000000000000000000000000000000000000"},"data":[]}
FALLBACK
        return 0
    fi

    # Extract this operator's public shares from cluster-lock
    local pubkeys
    pubkeys=$(jq -r --argjson idx "$operator_index" \
        '[.distributed_validators[].public_shares[$idx]] | map(select(. != null)) | .[]' \
        "$lock_file" 2>/dev/null || echo "")

    if [ -z "$pubkeys" ]; then
        cat > "$dest" <<'FALLBACK'
{"metadata":{"interchange_format_version":"5","genesis_validators_root":"0x0000000000000000000000000000000000000000000000000000000000000000"},"data":[]}
FALLBACK
        return 0
    fi

    # Build EIP-3076 JSON with one entry per validator
    local data_entries=""
    local first=true
    while IFS= read -r pk; do
        if [ "$first" = true ]; then
            first=false
        else
            data_entries="${data_entries},"
        fi
        data_entries="${data_entries}{\"pubkey\":\"${pk}\",\"signed_blocks\":[],\"signed_attestations\":[]}"
    done <<< "$pubkeys"

    cat > "$dest" <<EOF
{"metadata":{"interchange_format_version":"5","genesis_validators_root":"0x0000000000000000000000000000000000000000000000000000000000000000"},"data":[${data_entries}]}
EOF
}

# --- Main dispatch ---

# Detect "docker compose" subcommand
if [ "${1:-}" = "compose" ]; then
    shift  # consume "compose"

    # Parse compose subcommand
    compose_cmd="${1:-}"
    shift || true

    case "$compose_cmd" in
        ps)
            # docker compose ps <service>
            svc="${1:-}"
            if [ -n "$svc" ] && is_service_up "$svc"; then
                echo "NAME      IMAGE     COMMAND   SERVICE   CREATED   STATUS    PORTS"
                echo "${svc}-1  img       cmd       ${svc}    1m ago    Up 1m     "
            fi
            exit 0
            ;;
        stop)
            # docker compose stop <svc1> <svc2> ...
            for svc in "$@"; do
                mark_service "$svc" "stopped"
            done
            exit 0
            ;;
        up)
            # docker compose up -d <svc1> <svc2> ...
            # Skip the -d flag
            for arg in "$@"; do
                case "$arg" in
                    -d) ;;
                    *) mark_service "$arg" "running" ;;
                esac
            done
            exit 0
            ;;
        exec)
            # docker compose exec -T <svc> <cmd...>  (legacy ASDB export inside container)
            # Just succeed - the actual data is handled by cp
            exit 0
            ;;
        cp)
            # docker compose cp <container>:<src> <dest>
            # Generate EIP-3076 JSON at <dest>
            local_dest="${2:-}"
            if [ -z "$local_dest" ]; then
                # Maybe args are container:src dest
                local_dest="${2:-/dev/null}"
            fi
            # The arguments are: container:path localpath
            # $1 = container:path, $2 = local dest
            generate_eip3076 "${2:-/dev/null}"
            exit 0
            ;;
        run)
            # docker compose run --rm ... (ASDB export/import)
            # Parse arguments to find volume mounts and detect export operations
            asdb_export_dir=""
            is_export=false
            args=("$@")
            
            for ((idx=0; idx<${#args[@]}; idx++)); do
                arg="${args[$idx]}"
                case "$arg" in
                    -v)
                        # Next arg is the volume mount
                        next_idx=$((idx+1))
                        if [ $next_idx -lt ${#args[@]} ]; then
                            mount="${args[$next_idx]}"
                            host_path="${mount%%:*}"
                            container_path="${mount#*:}"
                            # Check if this is the asdb-export mount
                            if [[ "$container_path" == "/tmp/asdb-export"* ]]; then
                                asdb_export_dir="$host_path"
                            fi
                        fi
                        ;;
                    -v*)
                        # Combined -v/path:/path format
                        mount="${arg#-v}"
                        host_path="${mount%%:*}"
                        container_path="${mount#*:}"
                        if [[ "$container_path" == "/tmp/asdb-export"* ]]; then
                            asdb_export_dir="$host_path"
                        fi
                        ;;
                    *export*|slashing-protection-history)
                        is_export=true
                        ;;
                esac
            done
            
            # If this is an export operation with asdb-export mount, generate EIP-3076 file
            if [ "$is_export" = true ] && [ -n "$asdb_export_dir" ]; then
                mkdir -p "$asdb_export_dir"
                # Different VCs create files with different names
                # Lodestar/Teku/Nimbus: slashing-protection.json
                # Prysm: slashing_protection.json
                generate_eip3076 "$asdb_export_dir/slashing-protection.json"
                # Also create Prysm-style filename 
                cp "$asdb_export_dir/slashing-protection.json" "$asdb_export_dir/slashing_protection.json" 2>/dev/null || true
            fi
            
            exit 0
            ;;
        *)
            # Unknown compose command - pass through
            exec "${REAL_DOCKER}" compose "$compose_cmd" "$@"
            ;;
    esac
    exit 0
fi

# Non-compose commands
case "${1:-}" in
    info)
        # Pass through to real docker
        exec "${REAL_DOCKER}" "$@"
        ;;
    run)
        # Pass through to real docker, but strip -i/-t flags for background execution
        shift  # consume "run"
        cleaned_args=()
        volume_mounts=()
        charon_cmd=""
        new_enr=""
        operator_index=""
        lock_file_mount=""
        output_dir_mount=""

        while [ $# -gt 0 ]; do
            case "$1" in
                -it|-ti) ;;
                -i|-t|--interactive|--tty) ;;
                -v)
                    volume_mounts+=("$1" "$2")
                    cleaned_args+=("$1" "$2")
                    # Track volume mounts for mock replace-operator
                    case "$2" in
                        */.charon:*) lock_file_mount="${2%%:*}" ;;
                        *output:*) output_dir_mount="${2%%:*}" ;;
                    esac
                    shift
                    ;;
                -v*)
                    # -v/path:/path format
                    cleaned_args+=("$1")
                    local_mount="${1#-v}"
                    case "$local_mount" in
                        */.charon:*) lock_file_mount="${local_mount%%:*}" ;;
                        *output:*) output_dir_mount="${local_mount%%:*}" ;;
                    esac
                    ;;
                edit|"alpha")
                    # Detect charon edit/alpha edit commands
                    cleaned_args+=("$1")
                    charon_cmd="$1"
                    ;;
                replace-operator)
                    charon_cmd="replace-operator"
                    cleaned_args+=("$1")
                    ;;
                --new-enr=*)
                    new_enr="${1#--new-enr=}"
                    cleaned_args+=("$1")
                    ;;
                --new-operator-enr=*)
                    new_enr="${1#--new-operator-enr=}"
                    cleaned_args+=("$1")
                    ;;
                --old-operator-enr=*)
                    old_enr="${1#--old-operator-enr=}"
                    cleaned_args+=("$1")
                    ;;
                *) cleaned_args+=("$1") ;;
            esac
            shift
        done

        # Check if this is a replace-operator command (mock it since it doesn't exist in older versions)
        if [ "$charon_cmd" = "replace-operator" ] && [ -n "$new_enr" ] && [ -n "$old_enr" ]; then
            # Find the cluster-lock via volume mounts
            local_lock=""
            local_output=""
            for ((idx=0; idx<${#cleaned_args[@]}; idx++)); do
                case "${cleaned_args[$idx]}" in
                    -v)
                        next_idx=$((idx+1))
                        mount="${cleaned_args[$next_idx]:-}"
                        host_path="${mount%%:*}"
                        container_path="${mount#*:}"
                        container_path="${container_path%%:*}"
                        case "$container_path" in
                            */\.charon|*/.charon) local_lock="$host_path/cluster-lock.json" ;;
                            */output) local_output="$host_path" ;;
                        esac
                        ;;
                esac
            done

            if [ -n "$local_lock" ] && [ -f "$local_lock" ] && [ -n "$local_output" ]; then
                mkdir -p "$local_output"
                # Find operator index by matching old_enr
                operator_index=$(jq -r --arg enr "$old_enr" \
                    '.cluster_definition.operators | to_entries[] | select(.value.enr == $enr) | .key' \
                    "$local_lock" 2>/dev/null | head -n 1)
                
                if [ -z "$operator_index" ]; then
                    echo "Mock replace-operator: could not find operator with ENR: $old_enr" >&2
                    exit 1
                fi
                
                # Replace operator ENR at the found index using jq
                jq --argjson idx "$operator_index" --arg enr "$new_enr" \
                    '.cluster_definition.operators[$idx].enr = $enr' \
                    "$local_lock" > "$local_output/cluster-lock.json"
                exit 0
            else
                echo "Mock replace-operator: cannot find cluster-lock or output dir" >&2
                exit 1
            fi
        fi

        exec "${REAL_DOCKER}" run --user "$(id -u):$(id -g)" "${cleaned_args[@]}"
        ;;
    *)
        # Pass through everything else
        exec "${REAL_DOCKER}" "$@"
        ;;
esac
